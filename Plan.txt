--------------------------------------------------------------------------------

User Provides:
a files nested dictionary:
        {filename_1: {outputfile_1: lambda filter
                     outputfile_2: lambda filter
                     outputfile_3: lambda filter}

        filename_1: {outputfile_1: lambda filter
                     outputfile_2: lambda filter
                     outputfile_3: lambda filter}}
--------------------------------------------------------------------------------

# pytest plugins for async test and coroutine test
# file overrite
# append os path with file name
# date parsing


        file name, a dictionary of filters
        {file_name1: (car, make, year), filter_name_2: (mode, person, state)}
        etc: #the keys are the output files, the values are the fitlers (in
        this case headers)}

for file in files_dictionary:
    with file open:
        -extract headers --> create named tuple named tuple send next(line) to
        infer

        -infer data type--> sample the line and return a string

        -sample data row(take in parse key)
            sample data row call next  #now at data lines


    data_reader --> cast

    headers extract gets sent user defined headers, and sends those to filters

    filter_predicates --> recieves tracking headers yield 1

    filters -->
                recieves named tuple yield 2
                if all namedtuple values exist in named tuple from tracking
                fileds send to save data else consume it

    def pred_ford_green(data_row):
        return (data_row[idx_make].lower() == 'ford'
                and data_row[idx_color].lower() == 'green')

        filter_pink_cars = filter_data(lambda d: d[idx_color].lower() == 'pink',

        filter_ford_green = filter_data(pred_ford_green, out_ford_green)

        filter_older = filter_data(lambda d: d[idx_year] <= 2010, out_older)

        filters = (filter_pink_cars, filter_ford_green, filter_older)
        broadcaster = broadcast(filters)

# track fields
def filterpredicate(tuple: track_fileds):
    for track_field in track_fields:
        if all(namedtuple.track_field for trackfield in trackfields):
            return named.tuple

    
"Chevrolet Chevelle Malibu;18.0;8;307.0;130.0;3504.;12.0;70;US"




